** Ioc- design principle to invert flow of control-- Controlling of Java objects and their lifecycle is not done by the developers, hence the name Inversion Of Control.
** Dependecy Injection: implements IoC(Inversion of control) : refer https://medium.com/edureka/what-is-dependency-injection-5006b53af782
     -- dependency - @component (eg Class A)
        created bean in starter class as context.getBean(A.class);
   
  Types of DI: Constructor based, setters based, variable based

** @RequestParam -    Can be optional too
    Default value it may take
    takes URL query params
  eg:  /users/id?10

** @PathVariable
@GetMapping("/users/{id}")
public ResponseEntity<User> getUserById(@PathVariable("id") Long userId)

** @RestController= @controller+ @ResponseBody

** Bean and its Scope:  A bean is an object that is instantiated, assembled, and otherwise managed by a Spring IoC container
1.singleton- the container creates a single instance of that bean;
         all requests for that bean name will return the same object : default is singleton only.
2.prototype - new instance as per request
3.request
4.session
5.application
6.websocket
   3,4,5,6 are for web aware applications.


** @Bean vs. @Component

@Component and @Bean do two quite different things, and shouldn't be confused.

@Component (and @Service and @Repository) are used to auto-detect and auto-configure beans using classpath scanning. 
There's an implicit one-to-one mapping between the annotated class and the bean (i.e. one bean per class). 
Control of wiring is quite limited with this approach, since it's purely declarative.

@Bean is used to explicitly declare a single bean, rather than letting Spring do it automatically as above.
It decouples the declaration of the bean from the class definition, and lets you create and configure beans exactly how you choose.
@Bean annotation is used to indicate that a method instantiates, configures, 
and initializes a new object to be managed by the Spring IoC container. mostly third-party objects like RabbitMqTemplate, KafkaTemplate


** @Transactional--
   rollback happens for runtime, unchecked exceptions only. The checked exception does not trigger a rollback of the transaction. 
We can, of course, configure this behavior with the rollbackFor and noRollbackFor annotation parameters.

 eg: @Transactional(rollbackFor = MyCheckedException.class)
    public void foo() {

**@Scheduled(fixedDelay = 1000) -- Cron jobs

** @SpringBootApplication 
•	@EnableAutoConfiguration: enable Spring Boot’s auto-configuration mechanism
•	@ComponentScan: enable @Component scan on the package where the application is located.
•	@Configuration: allow to register extra beans in the context or import additional configuration classes



** ModelMapper- maaping between inetrnal entities and extrenal DTOs

** @transient- in @entity doent allow that value to persist in DB. There are certain fields or properties in an entity that should be ignored during the data persistence process such as the data which is being calculated for displaying, temporary variables, 
and other data which is relevant only within the application logic but is not required in the database

**spring.jpa.hibernate.ddl-auto=create(schema recretaed everytime app restarts, previous data is lost), validate,update(avoids data loss), create drop


**@websecurity: WebSecurityConfigurerAdapter Class
 protected void configure(HttpSecurity http)
        throws Exception
    {
           http.authorizeRequests()
            .antMatchers("/basic")
            .hasAnyRole("BASIC", "ADMIN")
            .antMatchers("/admin")
            .hasRole("ADMIN")
            .antMatchers("/")
            .permitAll()
            .anyRequest()
            .authenticated()


**@lazy - lazy initialiasation of bean. Generally object comes up as the project builds, with Lazy it will come on its first call.
