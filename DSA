1.) Anagram : sort -> equals

2.) Stock Buy-Sell: Max Profit: 
     public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0) {
            return 0;
        }

        int minPrice = Integer.MAX_VALUE;
        int maxProfit = 0;

        for (int price : prices) {
            if (price < minPrice) {
                minPrice = price;
            } else if (price - minPrice > maxProfit) {
                maxProfit = price - minPrice;
            }
        }

        return maxProfit;
    }
3.) Rotate Array
 : left rotation-> reverse (arr,0, len-1), reverse(arr,0,k-1), reverse(arr,k,len-1)

--------------- Longest Substring-------------
//2 pointers -> start & end , start will update by sliding window- end normally move

public static void main(String[] args) {
	Map<Character, Integer> map=new HashMap<>();
	
	String str="abcaabcd";
	int start=0;
	String output="";
	
	
	for (int end=0;end<str.length() ;end++) {
	Character	currChar=str.charAt(end);
		 
	   if (map.containsKey(currChar)) {
		   //if char is repeating, start needs to be updated
		   start= Math.max(start,map.get(currChar)+1 );
	   }
	    if (output.length()<(end-start+1)){
	    	output=str.substring(start,end+1);
	    }
	    map.put(currChar,end);
		 
		
	}
	System.out.print("=="+output);
	

}
--------------------Shift Odd-even (odd to left , even to right)--

  public static void shiftOddEven(int[] arr) {
        int left = 0, right = arr.length - 1;
        while (left < right) {
            // Increment left index if current number is odd
            while (arr[left] % 2 != 0 && left < right) {
                left++;
            }

            // Decrement right index if current number is even
            while (arr[right] % 2 == 0 && left < right) {
                right--;
            }

            // Swap even at left with odd at right
            if (left < right) {
                int temp = arr[left];
                arr[left] = arr[right];
                arr[right] = temp;
            }
        }
    }
-------------------------sliding window maximum problem, which finds the maximum in each subarray (window) of size k.
package practice;

import java.util.*;

public class Test {

    static int maxElement(int[] arr, int i, int j) {
        int max = Integer.MIN_VALUE; // Handles negative numbers

        while (i <= j) { // Inclusive of j
            if (max < arr[i]) {
                max = arr[i];
            }
            i++;
        }
        return max;
    }

    static List<Integer> maxList(int[] arr, int k) {
        List<Integer> list = new ArrayList<>();

        for (int start = 0; start <= arr.length - k; start++) {
            int end = start + k - 1;
            list.add(maxElement(arr, start, end));
        }

        return list;
    }

    public static void main(String[] args) {
        int arr[] = { 1, 3, -1, -3, 5, 3, 6, 7 };
        System.out.println(maxList(arr, 3));
    }
}

